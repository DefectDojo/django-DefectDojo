import json
import logging
import re
from collections import namedtuple
from pathlib import Path
from typing import Iterator, Optional, Iterable

import git
from django.conf import settings
from django.db import connection, transaction

UnprocessedVulnerability = namedtuple('UnprocessedVulnerability',
                                      ('vulnerability_id', 'url', 'title', 'description', 'cwe'))


class VulnerabilityMirror:
    """Manages a git repository mirror of vulnerability data."""

    __slots__ = ('_repository_root', '_remote_url', '_repo', '_logger')

    def __init__(self,
                 repository_root: str = settings.VULNDB_ROOT,
                 remote_url: str = settings.VULNDB_URL,
                 logger: logging.Logger = logging.getLogger(__name__)):
        self._repository_root = Path(repository_root)
        self._remote_url = remote_url
        self._logger = logger
        if not self._repository_root.exists():
            self._repository_root.mkdir(parents=True)
        git_dir = self._repository_root / '.git'
        if not git_dir.exists():
            self._logger.debug('Cloning vulnerability mirror from %s to %s', remote_url, repository_root)
            self._repo = self.__clone()
        else:
            self._logger.debug('Reusing existing checkout at %s', repository_root)
            self._repo = self.__update()

    def __clone(self) -> git.Repo:
        # TODO: consider using sparse checkout
        return git.Repo.clone_from(self._remote_url, self._repository_root, branch='master', single_branch=True)

    def __update(self) -> git.Repo:
        repo = git.Repo(self._repository_root)
        repo.remote().pull()
        return repo

    def __diff(self, from_revision: str, to_revision: Optional[str] = None) -> git.DiffIndex:
        return self._repo.commit(from_revision).diff(self._repo.commit(to_revision))

    def unprocessed_files(self, since_revision: Optional[str] = None) -> Iterator[str]:
        """Returns an iterator of file names that have been touched since the given revision. If no revision is given,
        lists all files in the repository tree."""
        if since_revision:
            return (diff.b_path for diff in self.__diff(since_revision) if diff.change_type in ('A', 'M'))
        else:
            return (blob.path for blob in self._repo.tree().traverse(lambda i, d: i.type == 'blob'))

    def __parse_file(self, filename: str) -> Iterator[UnprocessedVulnerability]:
        """Reads and parses a vulnerability file, returning an unsaved model object if it was valid."""
        with (self._repository_root / filename).open() as fp:
            contents = json.load(fp)
        metadata = contents.get('CVE_data_meta', dict())
        if metadata.get('STATE') != 'PUBLIC':
            # only want published CVEs
            return None
        cve = metadata['ID']
        url = 'https://cve.mitre.org/cgi-bin/cvename.cgi?name={}'.format(cve)
        title = metadata.get('TITLE', 'Untitled')
        description = None
        for datum in contents.get('description', dict()).get('description_data', []):
            if datum.get('lang') == 'eng':
                description = datum.get('value')
                break
        # yield multiple vulnerabilities if multiple CWEs are present
        for datum in contents.get('problemtype', dict()).get('problemtype_data', []):
            match = re.search(r'CWE-(\d+)', datum.get('value', ''))
            if match:
                cwe = int(match.group(1))
                yield UnprocessedVulnerability(cve, url, title, description, cwe)
        else:
            yield UnprocessedVulnerability(cve, url, title, description, None)

    def __parse_files(self, files: Iterable[str]) -> Iterator[UnprocessedVulnerability]:
        """Extracts vulnerability models from a list of file names."""
        for file in files:
            for vulnerability in self.__parse_file(file):
                yield vulnerability

    __INSERT_STATEMENT = 'INSERT INTO dojo_vulnerability (vulnerability_id,url,title,description,cwe,updated) VALUES (%s,%s,%s,%s,%s,now())'

    @transaction.atomic
    def process_files(self, files: Iterable[str]):
        statement = self.__INSERT_STATEMENT
        # add vendor-specific conflict resolution clause for updating existing vulnerabilities
        if connection.vendor == 'mysql':
            statement += ' ON DUPLICATE KEY UPDATE url=VALUES(url), title=VALUES(title), description=VALUES(description), cwe=VALUES(cwe), updated=now()'
        elif connection.vendor == 'postgresql':
            statement += ' ON CONFLICT (vulnerability_id) DO UPDATE SET url=excluded.url, title=excluded.title, description=excluded.description, cwe=excluded.cwe, updated=now()'
        with connection.cursor() as c:
            c.executemany(statement, self.__parse_files(files))

    @property
    def revision(self) -> str:
        """Returns the current git revision checked out in this repository mirror."""
        return self._repo.commit().hexsha
