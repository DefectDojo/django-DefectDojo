import json
import logging
import re
from pathlib import Path
from typing import Iterator, Optional, Iterable

import git
from django.conf import settings

from dojo.models import Vulnerability


class VulnerabilityMirror:
    """Manages a git repository mirror of vulnerability data."""

    __slots__ = ('_repository_root', '_remote_url', '_repo', '_logger')

    def __init__(self,
                 repository_root: str = settings.VULNDB_ROOT,
                 remote_url: str = settings.VULNDB_URL,
                 logger: logging.Logger = logging.getLogger(__name__)):
        self._repository_root = Path(repository_root)
        self._remote_url = remote_url
        self._logger = logger
        if not self._repository_root.exists():
            self._repository_root.mkdir(parents=True)
        git_dir = self._repository_root / '.git'
        if not git_dir.exists():
            self._logger.debug('Cloning vulnerability mirror from %s to %s', remote_url, repository_root)
            self._repo = self.__clone()
        else:
            self._logger.debug('Reusing existing checkout at %s', repository_root)
            self._repo = self.__update()

    def __clone(self) -> git.Repo:
        # TODO: consider using sparse checkout
        return git.Repo.clone_from(self._remote_url, self._repository_root, branch='master', single_branch=True)

    def __update(self) -> git.Repo:
        repo = git.Repo(self._repository_root)
        repo.remote().pull()
        return repo

    def __diff(self, from_revision: str, to_revision: Optional[str] = None) -> git.DiffIndex:
        return self._repo.commit(from_revision).diff(self._repo.commit(to_revision))

    def unprocessed_files(self, since_revision: Optional[str] = None) -> Iterator[str]:
        """Returns an iterator of file names that have been touched since the given revision. If no revision is given,
        lists all files in the repository tree."""
        if since_revision:
            return (diff.b_path for diff in self.__diff(since_revision) if diff.change_type in ('A', 'M'))
        else:
            return (blob.path for blob in self._repo.tree().traverse(lambda i, d: i.type == 'blob'))

    def __parse_file(self, filename: str) -> Optional[Vulnerability]:
        """Reads and parses a vulnerability file, returning an unsaved model object if it was valid."""
        with (self._repository_root / filename).open() as fp:
            contents = json.load(fp)
        if contents['data_type'] != 'CVE' or 'CVE_data_meta' not in contents:
            # not a CVE; we don't know how to parse
            return None
        metadata = contents['CVE_data_meta']
        if metadata['STATE'] != 'PUBLIC':
            # only want published CVEs
            return None
        cve = metadata['ID']
        url = 'https://cve.mitre.org/cgi-bin/cvename.cgi?name={}'.format(cve)
        if 'TITLE' in metadata:
            title = metadata['TITLE']
        else:
            title = 'Reserved issue'
        vulnerability = Vulnerability(vulnerability_id=cve, url=url, title=title)
        if 'description' in contents:
            for datum in contents['description']['description_data']:
                if datum['lang'] == 'eng':
                    vulnerability.description = datum['value']
        if 'problemtype' in contents:
            for datum in contents['problemtype']['problemtype_data']:
                if 'value' in datum:
                    match = re.search(r'CWE-(\d+)', datum['value'])
                    if match:
                        vulnerability.cwe_id = int(match.group(1))
                        break
        return vulnerability

    def parse_files(self, files: Iterable[str]) -> Iterator[Vulnerability]:
        """Extracts vulnerability models from a list of file names."""
        for filename in files:
            vulnerability = self.__parse_file(filename)
            if vulnerability is not None:
                yield vulnerability

    @property
    def revision(self) -> str:
        """Returns the current git revision checked out in this repository mirror."""
        return self._repo.commit().hexsha
