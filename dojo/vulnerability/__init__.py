import json
import logging
import re
from pathlib import Path
from typing import Iterator, Optional, Iterable

import git
from django.conf import settings
from django.db import transaction

from dojo.models import Vulnerability


class VulnerabilityMirror:
    """Manages a git repository mirror of vulnerability data."""

    __slots__ = ('_remote_url', '_repository_root', '_repo', '_logger')

    def __init__(self,
                 remote_url: str,
                 repository_root: str = settings.VULNDB_ROOT,
                 logger: logging.Logger = logging.getLogger(__name__)):
        self._remote_url = remote_url
        self._repository_root = Path(repository_root)
        self._logger = logger
        if not self._repository_root.exists():
            self._repository_root.mkdir(parents=True)
        git_dir = self._repository_root / '.git'
        if not git_dir.exists():
            self._logger.debug('Cloning vulnerability mirror from %s to %s', remote_url, repository_root)
            self._repo = self.__clone()
        else:
            self._logger.debug('Reusing existing checkout at %s', repository_root)
            self._repo = self.__update()

    def __clone(self) -> git.Repo:
        return git.Repo.clone_from(self._remote_url, self._repository_root, depth=1)

    def __update(self) -> git.Repo:
        repo = git.Repo(self._repository_root)
        repo.remote().pull()
        return repo

    def __diff(self, from_revision: str, to_revision: Optional[str] = None) -> git.DiffIndex:
        return self._repo.commit(from_revision).diff(self._repo.commit(to_revision))

    def unprocessed_files(self, since_revision: Optional[str] = None) -> Iterator[str]:
        """Returns an iterator of file names that have been touched since the given revision. If no revision is given,
        lists all files in the repository tree."""
        if since_revision:
            return (diff.b_path for diff in self.__diff(since_revision) if
                    diff.change_type in ('A', 'M') and diff.b_path.endswith('.json'))
        else:
            return (blob.path for blob in
                    self._repo.tree().traverse(lambda i, d: i.type == 'blob' and i.path.endswith('.json')))

    def __parse_file(self, filename: str) -> Optional[Vulnerability]:
        """Reads and parses a vulnerability file, returning an unsaved model object if it was valid."""

        def is_unpublished(data):
            return data.get('CVE_data_meta', dict()).get('STATE') != 'PUBLIC'

        def get_id_url_title(data):
            cve_id = data['CVE_data_meta']['ID']
            cve_url = 'https://cve.mitre.org/cgi-bin/cvename.cgi?name={}'.format(cve_id)
            cve_title = data['CVE_data_meta'].get('TITLE', 'Untitled')
            return cve_id, cve_url, cve_title

        def get_description(data):
            for datum in data.get('description', dict()).get('description_data', []):
                if datum.get('lang') == 'eng':
                    return datum.get('value')
            return None

        def get_cwe(data):
            for datum in data.get('problemtype', dict()).get('problemtype_data', []):
                for entry in datum.get('description', []):
                    match = re.search(r'CWE-(\d+)', entry.get('value', ''))
                    if match:
                        return int(match.group(1))
            return None

        with (self._repository_root / filename).open() as fp:
            contents = json.load(fp)
        if is_unpublished(contents):
            return None
        cve, url, title = get_id_url_title(contents)
        description = get_description(contents)
        cwe = get_cwe(contents)
        vulnerability, created = Vulnerability.objects.get_or_create(vulnerability_id=cve, url=url, title=title,
                                                                     description=description, cwe=cwe)
        return vulnerability

    # wrapping this in a transaction in order to batch upsert more quickly
    @transaction.atomic
    def process_files(self, files: Iterable[str]) -> Iterator[Vulnerability]:
        """Extracts vulnerability models from a list of file names."""
        for file in files:
            vulnerability = self.__parse_file(file)
            if vulnerability is not None:
                yield vulnerability

    @property
    def revision(self) -> str:
        """Returns the current git revision checked out in this repository mirror."""
        return self._repo.commit().hexsha
