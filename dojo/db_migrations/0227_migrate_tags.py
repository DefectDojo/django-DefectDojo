# Generated by Django 5.0.8 on 2024-09-12 18:22

import logging
from django.db import migrations
from django.db.models import Q

logger = logging.getLogger(__name__)

# Only apply the process to models that _could_ have tags
model_names = [
    "Product",
    "Endpoint",
    "Engagement",
    "Test",
    "Finding",
    "Finding_Template",
    "App_Analysis",
    "Objects_Product",
]


def clean_tag_value(tag: str) -> str:
    """
    Clean each tag value by:
    - Converting all commas to hyphens
    - Converting all spaces to underscores
    - Removing all single/double quotes
    """
    return tag.replace(",", "-").replace(" ", "_").replace('"', "").replace("'", "")


def clean_all_tag_fields(apps, schema_editor):
    """
    Cleans tag values for all models in the `model_names` list, removing unwanted characters.
    Updates both 'tags' and 'inherited_tags' fields where applicable.
    """
    updated_count = {}
    for model_name in model_names:
        TaggedModel = apps.get_model("dojo", model_name)
        unique_tags_per_model = {}
        count_per_model = 0
        # Only fetch the objects with tags that contain a character in violation
        queryset = (
            TaggedModel.objects.filter(
                Q(**{"tags__name__icontains": ","})
                | Q(**{"tags__name__icontains": " "})
                | Q(**{"tags__name__icontains": '"'})
                | Q(**{"tags__name__icontains": "'"})
            )
            .distinct()
            .prefetch_related("tags")
        )
        # Iterate over each instance to clean the tags. The iterator is used here
        # to prevent loading the entire queryset into memory at once. Instead, we
        # will only process 500 objects at a time
        for instance in queryset.iterator(chunk_size=500):
            # Get the current list of tags to work with
            raw_tags = instance.tags.all()
            # Clean each tag here while preserving the original value
            cleaned_tags = {tag.name: clean_tag_value(tag.name) for tag in raw_tags}
            # Quick check to avoid writing things without impact
            if cleaned_tags:
                instance.tags.set(list(cleaned_tags.values()), clear=True)
                count_per_model += 1
                # Update the running list of cleaned tags with the changes on this model
                unique_tags_per_model.update(cleaned_tags)
            # Add a quick logging statement every 100 objects cleaned
            if count_per_model > 0 and count_per_model % 100 == 0:
                logger.info(
                    f"{TaggedModel.__name__}.tags: cleaned {count_per_model} tags..."
                )
        # Update the final count of the tags cleaned for the given model
        if count_per_model:
            updated_count[f"{TaggedModel.__name__}"] = (
                count_per_model,
                unique_tags_per_model,
            )
    """
    Write a helpful statement about what tags were changed for each model in the list.
    It looks something like this:

    Product: 1 instances cleaned
      "quoted string with spaces" -> quoted_string_with_spaces
      "quoted with spaces, and also commas!" -> quoted_with_spaces-_and_also_commas!
      "quoted,comma,tag" -> quoted-comma-tag
    Engagement: 1 instances cleaned
      "quoted string with spaces" -> quoted_string_with_spaces
      "quoted with spaces, and also commas!" -> quoted_with_spaces-_and_also_commas!
      "quoted,comma,tag" -> quoted-comma-tag
    Test: 1 instances cleaned
      "quoted string with spaces" -> quoted_string_with_spaces
      "quoted with spaces, and also commas!" -> quoted_with_spaces-_and_also_commas!
      "quoted,comma,tag" -> quoted-comma-tag
    Finding: 1 instances cleaned
      "quoted string with spaces" -> quoted_string_with_spaces
      "quoted with spaces, and also commas!" -> quoted_with_spaces-_and_also_commas!
      "quoted,comma,tag" -> quoted-comma-tag
    """
    for key, (count, tags) in updated_count.items():
        logger.info(f"{key}: {count} instances cleaned")
        for old, new in tags.items():
            if old != new:
                logger.info(f"  {old} -> {new}")


def cannot_turn_back_time(apps, schema_editor):
    """
    We cannot possibly return to the original state without knowing
    the original value at the time the migration is revoked. Instead
    we will do nothing.
    """
    pass


class Migration(migrations.Migration):
    dependencies = [
        ("dojo", "0226_import_history_left_untouched_rename"),
    ]

    operations = [
        migrations.RunPython(clean_all_tag_fields, cannot_turn_back_time),
    ]
